<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Live Mixer</title>
<script src="main.js"></script>
<script>
// OSC Bridge connection for FX parameter control
let oscWs = null;
let oscConnected = false;

function connectOSC() {
  // Connect to OSC bridge on port 3000
  const host = window.location.hostname || 'localhost';
  oscWs = new WebSocket(`ws://${host}:3000/osc`);
  
  oscWs.onopen = () => {
    console.log('OSC bridge connected');
    oscConnected = true;
  };
  
  oscWs.onclose = () => {
    console.log('OSC bridge disconnected');
    oscConnected = false;
    setTimeout(connectOSC, 3000);
  };
  
  oscWs.onerror = () => {
    oscConnected = false;
  };
  
  oscWs.onmessage = (event) => {
    try {
      const data = JSON.parse(event.data);
      if (data.type === 'osc') {
        handleOSCResponse(data.address, data.args);
      } else if (data.type === 'fxValues') {
        handleFxValues(data);
      }
    } catch(e) {}
  };
}

function sendOSC(address, value) {
  if (oscWs && oscWs.readyState === WebSocket.OPEN) {
    oscWs.send(JSON.stringify({
      type: 'osc',
      address: address,
      args: [{ type: 'f', value: value }]
    }));
    return true;
  }
  return false;
}

function sendFxCommand(trackIdx, fxIdx, paramIdx, value) {
  if (oscWs && oscWs.readyState === WebSocket.OPEN) {
    oscWs.send(JSON.stringify({
      type: 'fx',
      trackIdx: trackIdx,
      fxIdx: fxIdx,
      paramIdx: paramIdx,
      value: value
    }));
    return true;
  }
  return false;
}

function sendFxBypass(trackIdx, fxIdx) {
  if (oscWs && oscWs.readyState === WebSocket.OPEN) {
    oscWs.send(JSON.stringify({
      type: 'fxBypass',
      trackIdx: trackIdx,
      fxIdx: fxIdx
    }));
    return true;
  }
  return false;
}

function handleOSCResponse(address, args) {
  // Handle FX param responses: /track/N/fx/M/fxparam/P/value
  const match = address.match(/\/track\/(\d+)\/fx\/(\d+)\/fxparam\/(\d+)\/value/);
  if (match && args && args[0]) {
    const trackIdx = parseInt(match[1]);
    const fxIdx = parseInt(match[2]);
    const paramIdx = parseInt(match[3]);
    const value = args[0].value;
    
    if (activeFxChannel === trackIdx) {
      updateFxKnobFromOSC(fxIdx, paramIdx, value);
    }
  }
}

function handleFxValues(data) {
  if (data.trackIdx !== activeFxChannel) return;
  
  // Update bypass buttons
  Object.entries(data.bypassed || {}).forEach(([fxIdx, bypassed]) => {
    const btn = document.querySelector(`.fx-bypass[data-fx-idx="${fxIdx}"]`);
    if (btn) {
      btn.classList.toggle('bypassed', bypassed);
      btn.textContent = bypassed ? 'OFF' : 'ON';
    }
  });
  
  // Update param knobs
  (data.params || []).forEach(({ fxIdx, paramIdx, value }) => {
    const knob = document.querySelector(`.fx-param-knob[data-fx-idx="${fxIdx}"][data-param-idx="${paramIdx}"]`);
    if (knob) {
      knob.dataset.value = value;
      knob.innerHTML = createKnobSVG(value);
      
      const paramContainer = knob.closest('.fx-param');
      const valueDisplay = paramContainer?.querySelector('.fx-param-value');
      if (valueDisplay) {
        valueDisplay.textContent = formatFxValue(fxIdx, paramIdx, value);
      }
    }
  });
}

function requestFxValues(trackIdx) {
  if (oscWs && oscWs.readyState === WebSocket.OPEN) {
    oscWs.send(JSON.stringify({
      type: 'fxRead',
      trackIdx: trackIdx
    }));
  }
}

function updateFxKnobFromOSC(fxIdx, paramIdx, value) {
  const knob = document.querySelector(`.fx-param-knob[data-fx-idx="${fxIdx}"][data-param-idx="${paramIdx}"]`);
  if (knob) {
    knob.dataset.value = value;
    knob.innerHTML = createKnobSVG(value);
    const paramContainer = knob.closest('.fx-param');
    const valueDisplay = paramContainer?.querySelector('.fx-param-value');
    if (valueDisplay) {
      valueDisplay.textContent = formatFxValue(fxIdx, paramIdx, value);
    }
  }
}

// Connect on load
connectOSC();
</script>

<style>
* {
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  background: #1a1a1a;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  margin: 0;
  padding: 0;
  overflow: hidden;
  height: 100vh;
  height: 100dvh; /* Dynamic viewport height - accounts for mobile address bar */
  user-select: none;
}

/* Header */
.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: #0d0d0d;
  border-bottom: 1px solid #333;
}

.title {
  font-size: 18px;
  font-weight: 600;
}

.layer-tabs {
  display: flex;
  gap: 4px;
}

.layer-tab {
  padding: 8px 16px;
  background: #333;
  border: none;
  border-radius: 6px;
  color: #aaa;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
}

.layer-tab.active {
  background: #4a9eff;
  color: #fff;
}

.layer-tab.mon1.active { background: #ff9500; }
.layer-tab.mon2.active { background: #30d158; }
.layer-tab.mon3.active { background: #5ac8fa; }
.layer-tab.mon4.active { background: #ff2d55; }
.layer-tab.mon5.active { background: #af52de; }
.layer-tab.mon6.active { background: #ffcc00; }

/* Header Controls */
.header-controls {
  display: flex;
  gap: 8px;
}

.header-btn {
  padding: 8px 12px;
  background: #333;
  border: 1px solid #555;
  border-radius: 6px;
  color: #aaa;
  font-size: 12px;
  font-weight: 600;
  cursor: pointer;
}

.header-btn:active {
  background: #444;
}

.header-btn.fx-master {
  color: #30d158;
  border-color: #30d158;
}

.header-btn.fx-master.bypassed {
  color: #ff453a;
  border-color: #ff453a;
  background: #3a2a2a;
}

.header-btn.reset-btn {
  font-size: 16px;
  padding: 6px 12px;
}

/* Reset Menu */
.reset-menu-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.8);
  z-index: 300;
  display: none;
  justify-content: center;
  align-items: center;
  padding: 20px;
}

.reset-menu-overlay.show {
  display: flex;
}

.reset-menu {
  background: #2a2a2a;
  border-radius: 16px;
  padding: 20px;
  width: 100%;
  max-width: 320px;
}

.reset-menu-title {
  font-size: 18px;
  font-weight: 600;
  text-align: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #444;
}

.reset-option {
  display: block;
  width: 100%;
  padding: 14px 16px;
  margin-bottom: 8px;
  background: #333;
  border: 1px solid #444;
  border-radius: 8px;
  color: #fff;
  font-size: 14px;
  text-align: left;
  cursor: pointer;
}

.reset-option:active {
  background: #444;
}

.reset-option.reset-all {
  background: #5a2a2a;
  border-color: #ff453a;
  color: #ff453a;
}

.reset-cancel {
  display: block;
  width: 100%;
  padding: 14px 16px;
  margin-top: 12px;
  background: transparent;
  border: 1px solid #666;
  border-radius: 8px;
  color: #888;
  font-size: 14px;
  text-align: center;
  cursor: pointer;
}

.reset-cancel:active {
  background: #333;
}

/* Mixer Container */
#mixer-container {
  display: flex;
  height: calc(100vh - 52px);
  height: calc(100dvh - 52px); /* Dynamic viewport height for mobile */
  overflow-x: auto;
  overflow-y: hidden;
  padding: 8px;
  padding-bottom: calc(8px + env(safe-area-inset-bottom, 0));
  gap: 6px;
  scroll-snap-type: x proximity;
}

/* Channel Strip */
.channel {
  background: linear-gradient(180deg, #2a2a2a 0%, #1e1e1e 100%);
  border-radius: 10px;
  width: 90px;
  min-width: 90px;
  padding: 8px 6px;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  scroll-snap-align: start;
  border: 1px solid #3a3a3a;
}

@media (max-width: 768px) {
  .channel {
    width: 95px;
    min-width: 95px;
    padding: 10px 8px;
  }
}

.channel.master {
  background: linear-gradient(180deg, #3a2a2a 0%, #2a1a1a 100%);
  border-color: #5a3a3a;
}

.colorbar {
  height: 4px;
  border-radius: 2px;
  margin-bottom: 4px;
}

.track-name {
  font-size: 10px;
  font-weight: 600;
  text-align: center;
  margin-bottom: 6px;
  height: 24px;
  line-height: 12px;
  overflow: hidden;
  color: #ddd;
  cursor: pointer;
  padding: 2px;
  border-radius: 4px;
}

.track-name:hover {
  background: #3a3a3a;
}

.track-name-input {
  width: 100%;
  background: #444;
  border: 1px solid #4a9eff;
  border-radius: 4px;
  color: #fff;
  font-size: 10px;
  font-weight: 600;
  text-align: center;
  padding: 2px;
  outline: none;
}

/* Sends Section */
.sends-section {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 8px;
}

.send-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.send-label {
  font-size: 10px;
  font-weight: 600;
  color: #888;
  width: 24px;
}

.send-knob-container {
  flex: 1;
  display: flex;
  justify-content: center;
}

@media (max-width: 768px) {
  .sends-section {
    gap: 8px;
    margin-bottom: 10px;
  }
  
  .send-label {
    font-size: 11px;
    width: 28px;
  }
}

.knob {
  width: 44px;
  height: 44px;
  position: relative;
  cursor: pointer;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  background: none;
  border: none;
  padding: 0;
  -webkit-appearance: none;
  appearance: none;
}

.knob svg {
  width: 100%;
  height: 100%;
}

.knob-track {
  fill: none;
  stroke: #444;
  stroke-width: 5;
}

.knob-value {
  fill: none;
  stroke: #4a9eff;
  stroke-width: 5;
  stroke-linecap: round;
}

.knob.reverb .knob-value { stroke: #bf5af2; }
.knob.mon1 .knob-value { stroke: #ff9500; }
.knob.mon2 .knob-value { stroke: #30d158; }
.knob.mon3 .knob-value { stroke: #5ac8fa; }
.knob.mon4 .knob-value { stroke: #ff2d55; }
.knob.pan .knob-value { stroke: #888; }

.knob.dragging {
  transform: scale(1.15);
  z-index: 20;
}

@media (max-width: 768px) {
  .knob {
    width: 52px;
    height: 52px;
  }
}

.pan-section {
  display: flex;
  justify-content: center;
  margin-bottom: 4px;
}

.knob-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px;
  font-weight: 600;
  color: #ccc;
  pointer-events: none;
}

@media (max-width: 768px) {
  .knob-text {
    font-size: 11px;
  }
}

/* Link Button */
.link-btn {
  background: #2a2a2a;
  border: 1px solid #444;
  border-radius: 4px;
  color: #666;
  font-size: 10px;
  padding: 4px;
  margin-bottom: 4px;
  cursor: pointer;
  text-align: center;
}

.link-btn:active, .link-btn.active {
  background: #4a9eff;
  color: #fff;
  border-color: #4a9eff;
}

.channel.linked {
  border-color: #4a9eff;
}

/* FX Button */
.fx-btn {
  background: #333;
  border: 1px solid #555;
  border-radius: 6px;
  color: #aaa;
  font-size: 10px;
  padding: 6px 4px;
  margin-bottom: 6px;
  cursor: pointer;
  text-align: center;
}

.fx-btn:active {
  background: #444;
}

.fx-btn.has-processing {
  color: #4a9eff;
  border-color: #4a9eff;
}

/* Fader Section */
.fader-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
}

.fader {
  position: relative;
  flex: 1;
  background: #111;
  border-radius: 6px;
  overflow: hidden;
  min-height: 120px;
}

.meter-container {
  position: absolute;
  bottom: 0;
  left: 4px;
  right: 4px;
  top: 0;
  display: flex;
  gap: 2px;
}

.meter {
  flex: 1;
  background: #1a1a1a;
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}

.meter-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, 
    #30d158 0%, 
    #30d158 60%, 
    #ffd60a 75%, 
    #ff453a 95%
  );
  transition: height 0.05s;
}

.fader-handle {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: 90%;
  height: 28px;
  background: linear-gradient(180deg, #666 0%, #444 50%, #333 100%);
  border-radius: 4px;
  border: 1px solid #888;
  touch-action: none;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
}

.fader-handle::after {
  content: '';
  width: 60%;
  height: 2px;
  background: #aaa;
  border-radius: 1px;
}

.fader-db {
  text-align: center;
  font-size: 10px;
  color: #888;
  padding: 4px 0;
  font-variant-numeric: tabular-nums;
}

/* Buttons Row */
.buttons-row {
  display: flex;
  gap: 4px;
  margin-top: 6px;
  flex-shrink: 0;
  padding-bottom: env(safe-area-inset-bottom, 0);
}

.btn {
  flex: 1;
  padding: 8px 4px;
  border: none;
  border-radius: 6px;
  font-size: 10px;
  font-weight: 600;
  cursor: pointer;
}

.btn-mute {
  background: #333;
  color: #888;
}

.btn-mute.active {
  background: #ff453a;
  color: #fff;
}

.btn-solo {
  background: #333;
  color: #888;
}

.btn-solo.active {
  background: #ffd60a;
  color: #000;
}

/* FX Panel Overlay */
.fx-panel-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.8);
  z-index: 100;
  display: none;
  justify-content: center;
  align-items: flex-end;
  padding: 20px;
}

.fx-panel-overlay.show {
  display: flex;
}

.fx-panel {
  background: #2a2a2a;
  border-radius: 16px 16px 0 0;
  width: 100%;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
  padding: 16px;
}

.fx-panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 16px;
  padding-bottom: 12px;
  border-bottom: 1px solid #444;
}

.fx-panel-title {
  font-size: 18px;
  font-weight: 600;
}

.fx-panel-close {
  background: #444;
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  color: #fff;
  font-size: 18px;
  cursor: pointer;
}

.fx-section {
  background: #222;
  border-radius: 12px;
  padding: 12px;
  margin-bottom: 12px;
}

.fx-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.fx-section-title {
  font-size: 14px;
  font-weight: 600;
  color: #ddd;
}

.fx-bypass {
  padding: 6px 12px;
  background: #30d158;
  border: none;
  border-radius: 4px;
  color: #fff;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
}

.fx-bypass.bypassed {
  background: #666;
  color: #aaa;
}

.fx-params {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
  gap: 12px;
}

.fx-param {
  text-align: center;
}

.fx-param-label {
  font-size: 9px;
  color: #888;
  margin-bottom: 4px;
  text-transform: uppercase;
}

.fx-param-knob {
  width: 64px;
  height: 64px;
  margin: 0 auto 6px;
  position: relative;
  cursor: pointer;
  touch-action: none;
  -webkit-user-select: none;
  user-select: none;
  background: none;
  border: none;
  padding: 0;
  -webkit-appearance: none;
  appearance: none;
}

.fx-param-knob svg {
  width: 100%;
  height: 100%;
}

.fx-param-knob .knob-track {
  stroke-width: 6;
}

.fx-param-knob .knob-value {
  stroke-width: 6;
}

.fx-param-knob.dragging {
  transform: scale(1.15);
  z-index: 20;
}

.fx-param-value {
  font-size: 12px;
  font-weight: 500;
  color: #ccc;
  font-variant-numeric: tabular-nums;
}

@media (max-width: 768px) {
  .fx-param-knob {
    width: 80px;
    height: 80px;
    margin: 0 auto 8px;
  }
  
  .fx-param-knob .knob-track,
  .fx-param-knob .knob-value {
    stroke-width: 7;
  }
  
  .fx-param-value {
    font-size: 14px;
  }
  
  .fx-param-label {
    font-size: 11px;
    margin-bottom: 6px;
  }
  
  .fx-params {
    gap: 16px;
  }
}

/* EQ Specific */
.eq-band {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.eq-freq {
  font-size: 9px;
  color: #666;
}

/* EQ Graph */
.eq-graph-container {
  margin-top: 16px;
  background: #1a1a1a;
  border-radius: 8px;
  padding: 12px;
}

.eq-graph {
  width: 100%;
  height: 120px;
  position: relative;
}

.eq-graph svg {
  width: 100%;
  height: 100%;
}

.eq-grid-line {
  stroke: #333;
  stroke-width: 1;
}

.eq-grid-line-zero {
  stroke: #444;
  stroke-width: 1.5;
}

.eq-curve {
  fill: none;
  stroke: #4a9eff;
  stroke-width: 2.5;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.eq-curve-fill {
  fill: url(#eq-gradient);
  opacity: 0.3;
}

.eq-freq-labels {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  padding: 0 4px;
}

.eq-freq-label {
  font-size: 8px;
  color: #555;
}

.eq-db-labels {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  padding: 2px 0;
  pointer-events: none;
}

.eq-db-label {
  font-size: 8px;
  color: #555;
  background: #1a1a1a;
  padding: 0 4px;
}

/* Gate Meter - shows gate open/closed status */
.gate-meter {
  height: 24px;
  background: #222;
  border-radius: 6px;
  margin-top: 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
}

.gate-meter-bg {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #1a1a1a;
  border-radius: 6px;
}

.gate-meter-fill {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  background: linear-gradient(90deg, #30d158 0%, #40e868 100%);
  width: 0%;
  transition: width 0.05s ease-out;
  border-radius: 6px 0 0 6px;
}

.gate-meter-label {
  position: relative;
  z-index: 1;
  font-size: 10px;
  font-weight: 700;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.gate-meter.open .gate-meter-label {
  color: #fff;
}

.gate-meter.open .gate-meter-fill {
  width: 100%;
}

/* Comp GR Meter - shows gain reduction */
.gr-meter-container {
  margin-top: 12px;
  background: #1a1a1a;
  border-radius: 6px;
  padding: 8px;
}

.gr-meter-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.gr-meter-title {
  font-size: 9px;
  font-weight: 600;
  color: #666;
  text-transform: uppercase;
}

.gr-meter-value {
  font-size: 11px;
  font-weight: 700;
  color: #ff9500;
  font-variant-numeric: tabular-nums;
}

.gr-meter {
  height: 12px;
  background: #333;
  border-radius: 4px;
  display: flex;
  justify-content: flex-end;
  overflow: hidden;
  position: relative;
}

.gr-meter-fill {
  height: 100%;
  background: linear-gradient(90deg, #ff9500 0%, #ffcc00 100%);
  width: 0%;
  transition: width 0.05s ease-out;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
}

.gr-meter-scale {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  justify-content: space-between;
  padding: 0 4px;
  pointer-events: none;
}

.gr-meter-tick {
  width: 1px;
  height: 100%;
  background: rgba(255,255,255,0.1);
}

/* Popup Fader for Knobs */
.popup-fader-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0,0,0,0.6);
  z-index: 200;
  display: none;
  justify-content: center;
  align-items: center;
}

.popup-fader-overlay.show {
  display: flex;
}

.popup-fader {
  background: #2a2a2a;
  border-radius: 16px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  align-items: center;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
  min-width: 120px;
}

.popup-fader-label {
  font-size: 14px;
  font-weight: 600;
  color: #fff;
  margin-bottom: 12px;
  text-transform: uppercase;
}

.popup-fader-track {
  width: 60px;
  height: 200px;
  background: #111;
  border-radius: 8px;
  position: relative;
  touch-action: none;
  margin-bottom: 12px;
}

.popup-fader-fill {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(to top, #4a9eff 0%, #7ab8ff 100%);
  border-radius: 0 0 8px 8px;
}

.popup-fader-handle {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: 52px;
  height: 28px;
  background: linear-gradient(180deg, #777 0%, #555 50%, #444 100%);
  border-radius: 6px;
  border: 2px solid #999;
  z-index: 10;
}

.popup-fader-handle::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 28px;
  height: 3px;
  background: #ccc;
  border-radius: 2px;
}

.popup-fader-value {
  font-size: 18px;
  font-weight: 600;
  color: #fff;
  background: #333;
  padding: 8px 16px;
  border-radius: 6px;
  min-width: 80px;
  text-align: center;
}

/* Frequency Slider for EQ */
.popup-freq-container {
  width: 100%;
  margin-top: 16px;
  display: none;
}

.popup-freq-container.show {
  display: block;
}

.popup-freq-label {
  font-size: 11px;
  color: #888;
  text-transform: uppercase;
  margin-bottom: 8px;
  text-align: center;
}

.popup-freq-track {
  width: 100%;
  height: 40px;
  background: #111;
  border-radius: 8px;
  position: relative;
  touch-action: none;
}

.popup-freq-fill {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  background: linear-gradient(90deg, #30d158 0%, #4a9eff 50%, #ff9500 100%);
  border-radius: 8px 0 0 8px;
  opacity: 0.3;
}

.popup-freq-handle {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 28px;
  height: 34px;
  background: linear-gradient(180deg, #777 0%, #555 50%, #444 100%);
  border-radius: 6px;
  border: 2px solid #999;
  z-index: 10;
}

.popup-freq-value {
  font-size: 14px;
  font-weight: 600;
  color: #4a9eff;
  text-align: center;
  margin-top: 8px;
  font-variant-numeric: tabular-nums;
}

.popup-freq-range {
  display: flex;
  justify-content: space-between;
  font-size: 9px;
  color: #555;
  margin-top: 4px;
  padding: 0 4px;
}

@media (max-width: 768px) {
  .popup-fader-track {
    width: 70px;
    height: 250px;
  }
  
  .popup-fader-handle {
    width: 60px;
    height: 32px;
  }
  
  .popup-fader-value {
    font-size: 20px;
  }
}

/* Scrollbar */
#mixer-container::-webkit-scrollbar {
  height: 6px;
}

#mixer-container::-webkit-scrollbar-track {
  background: #111;
}

#mixer-container::-webkit-scrollbar-thumb {
  background: #444;
  border-radius: 3px;
}
</style>
</head>

<body>
<div class="header">
  <div class="title">Live Mixer</div>
  <div class="header-controls">
    <button class="header-btn fx-master" id="globalFxBtn" onclick="toggleGlobalFx()" title="Global FX On/Off">FX</button>
    <button class="header-btn reset-btn" onclick="openResetMenu()" title="Reset Options">‚Ü∫</button>
  </div>
  <div class="layer-tabs">
    <button class="layer-tab active" data-layer="foh">FOH</button>
    <button class="layer-tab mon1" data-layer="mon1">MON1</button>
    <button class="layer-tab mon2" data-layer="mon2">MON2</button>
  </div>
</div>

<!-- Reset Menu Overlay -->
<div class="reset-menu-overlay" id="reset-menu-overlay" onclick="closeResetMenu(event)">
  <div class="reset-menu" onclick="event.stopPropagation()">
    <div class="reset-menu-title">Reset Options</div>
    <button class="reset-option" onclick="confirmReset('faders')">üéöÔ∏è Reset All Faders to Unity</button>
    <button class="reset-option" onclick="confirmReset('eq')">üìä Reset All EQs to Flat</button>
    <button class="reset-option" onclick="confirmReset('gates')">üöß Reset All Gates to Default</button>
    <button class="reset-option" onclick="confirmReset('comps')">üîä Reset All Compressors to Default</button>
    <button class="reset-option reset-all" onclick="confirmReset('all')">‚ö†Ô∏è Reset Everything</button>
    <button class="reset-cancel" onclick="closeResetMenu()">Cancel</button>
  </div>
</div>

<div id="mixer-container"></div>

<!-- Popup Fader for touch-friendly knob adjustment -->
<div class="popup-fader-overlay" id="popup-fader-overlay" onclick="closePopupFader(event)">
  <div class="popup-fader" onclick="event.stopPropagation()">
    <div class="popup-fader-label" id="popup-fader-label">Parameter</div>
    <div class="popup-fader-track" id="popup-fader-track">
      <div class="popup-fader-fill" id="popup-fader-fill"></div>
      <div class="popup-fader-handle" id="popup-fader-handle"></div>
    </div>
    <div class="popup-fader-value" id="popup-fader-value">0</div>
    <div class="popup-freq-container" id="popup-freq-container">
      <div class="popup-freq-label">Frequency</div>
      <div class="popup-freq-track" id="popup-freq-track">
        <div class="popup-freq-fill" id="popup-freq-fill"></div>
        <div class="popup-freq-handle" id="popup-freq-handle"></div>
      </div>
      <div class="popup-freq-value" id="popup-freq-value">500 Hz</div>
      <div class="popup-freq-range">
        <span id="popup-freq-min">20 Hz</span>
        <span id="popup-freq-max">20 kHz</span>
      </div>
    </div>
  </div>
</div>

<div class="fx-panel-overlay" id="fx-overlay">
  <div class="fx-panel">
    <div class="fx-panel-header">
      <div class="fx-panel-title" id="fx-panel-title">Channel FX</div>
      <button class="fx-panel-close" onclick="closeFxPanel()">√ó</button>
    </div>
    <div id="fx-panel-content"></div>
  </div>
</div>

<script>
// Configuration
const REVERB_TRACK_NAME = "REVERB";
const INPUT_PREFIX = "IN/";
const MON1_PREFIX = "M1/";
const MON2_PREFIX = "M2/";

// State
let currentLayer = "foh";
let tracks = {};
let inputTracks = [];
let fohTracks = []; // Includes inputs + reverb
let monitorBuses = {}; // Dynamic: { "M1": [...], "M2": [...], "M3": [...] }
let monitorOutputTracks = {}; // { "M1": { idx, name, color }, "M2": ... }
let reverbTrackIdx = null;
let masterTrackIdx = null; // Will be 0 for Reaper master
let activeFxChannel = null;
let activeFxType = null; // "input" or "output" - determines FX panel layout
let initialized = false;

// Map input numbers to monitor track indices for each bus
let inputToMonitorMap = {}; // { "M1": { "1": idx, "2": idx }, "M2": {...} }

// Stereo link groups: array of arrays of track indices
let linkedGroups = [];

// Discovered monitor prefixes (for dynamic tabs)
let monitorPrefixes = [];

// Custom track names (stored locally, keyed by input number)
let customNames = {};

// Load custom names from localStorage
try {
  const saved = localStorage.getItem('mixerCustomNames');
  if (saved) customNames = JSON.parse(saved);
} catch(e) {}

// Edit track name
function editTrackName(el, trackNum) {
  if (!trackNum || trackNum === "REV" || trackNum === "VERB") return;
  
  const currentName = customNames[trackNum] || trackNum;
  const input = document.createElement("input");
  input.type = "text";
  input.className = "track-name-input";
  input.value = currentName;
  input.maxLength = 12;
  
  el.innerHTML = "";
  el.appendChild(input);
  input.focus();
  input.select();
  
  function save() {
    const newName = input.value.trim() || trackNum;
    customNames[trackNum] = newName;
    localStorage.setItem('mixerCustomNames', JSON.stringify(customNames));
    
    // Update all displays of this track
    document.querySelectorAll(`.track-name[data-track-num="${trackNum}"]`).forEach(nameEl => {
      nameEl.textContent = newName;
    });
  }
  
  input.onblur = save;
  input.onkeydown = (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      input.blur();
    } else if (e.key === "Escape") {
      input.value = currentName;
      input.blur();
    }
  };
}

// FX Parameter definitions for ReaPlugs
const FX_DEFS = {
  gate: {
    name: "Gate",
    fxIndex: 0,
    params: [
      { name: "Threshold", idx: 0, min: -60, max: 0, unit: "dB" },
      { name: "Attack", idx: 4, min: 0, max: 100, unit: "ms" },
      { name: "Hold", idx: 5, min: 0, max: 500, unit: "ms" },
      { name: "Release", idx: 6, min: 0, max: 1000, unit: "ms" }
    ]
  },
  comp: {
    name: "Compressor",
    fxIndex: 1,
    params: [
      { name: "Threshold", idx: 0, min: -60, max: 0, unit: "dB" },
      { name: "Ratio", idx: 3, min: 1, max: 20, unit: ":1" },
      { name: "Attack", idx: 4, min: 0, max: 100, unit: "ms" },
      { name: "Release", idx: 5, min: 0, max: 1000, unit: "ms" }
    ]
  },
  eq: {
    name: "EQ",
    fxIndex: 2,
    bands: [
      { name: "Low", freqIdx: 1, gainIdx: 2, type: "shelf" },
      { name: "Lo-Mid", freqIdx: 5, gainIdx: 6 },
      { name: "Hi-Mid", freqIdx: 9, gainIdx: 10 },
      { name: "High", freqIdx: 13, gainIdx: 14, type: "shelf" }
    ]
  }
};

// Utility functions
function volToDb(vol) {
  if (vol < 0.0000001) return -Infinity;
  return Math.log(vol) * 8.68588963806;
}

function dbToVol(db) {
  if (db <= -60) return 0;
  return Math.exp(db / 8.68588963806);
}

function formatDb(db) {
  if (db <= -60) return "-‚àû";
  return db.toFixed(1);
}

// Format FX parameter value for display
function formatFxValue(fxIdx, paramIdx, value) {
  // Gate (FX 0) - ReaGate
  if (fxIdx === 0) {
    if (paramIdx === 0) return ((value * 120) - 60).toFixed(0) + " dB"; // Threshold (-60 to +60)
    if (paramIdx === 1) return (value * 1000).toFixed(1) + " ms"; // Attack (0-1000ms)
    if (paramIdx === 2) return (value * 1000).toFixed(0) + " ms"; // Release (0-1000ms)
    if (paramIdx === 4) return (value * 1000).toFixed(0) + " ms"; // Hold (0-1000ms)
  }
  // Compressor (FX 1) - ReaComp
  if (fxIdx === 1) {
    if (paramIdx === 0) return ((value * 120) - 60).toFixed(0) + " dB"; // Threshold
    if (paramIdx === 1) { // Ratio (logarithmic 1:1 to 100:1)
      const ratio = Math.pow(100, value);
      return ratio < 10 ? ratio.toFixed(1) + ":1" : ratio.toFixed(0) + ":1";
    }
    if (paramIdx === 2) return (value * 1000).toFixed(1) + " ms"; // Attack
    if (paramIdx === 3) return (value * 1000).toFixed(0) + " ms"; // Release
  }
  // EQ (FX 2) - ReaEQ
  if (fxIdx === 2) {
    // HPF frequency (param 12) - logarithmic frequency scale
    if (paramIdx === 12) {
      const freq = 20 * Math.pow(1000, value); // 20Hz to 20kHz
      return freq < 1000 ? freq.toFixed(0) + " Hz" : (freq/1000).toFixed(1) + " kHz";
    }
    // Gain params (1, 4, 7, 10)
    if ([1, 4, 7, 10].includes(paramIdx)) {
      return ((value - 0.5) * 48).toFixed(1) + " dB"; // ReaEQ is ¬±24dB range
    }
  }
  return (value * 100).toFixed(0) + "%";
}

function colorFromReaper(col) {
  if (!col || col === "0") return "#666";
  let v = parseInt(col) >>> 0;
  let r = (v >> 16) & 0xFF;
  let g = (v >> 8) & 0xFF;
  let b = v & 0xFF;
  return `rgb(${r},${g},${b})`;
}

// Knob SVG generation
function createKnobSVG(value, className = "") {
  const radius = 12;
  const circumference = 2 * Math.PI * radius;
  const startAngle = 135;
  const endAngle = 405;
  const range = endAngle - startAngle;
  const valueAngle = startAngle + (value * range);
  const dashOffset = circumference * (1 - value * 0.75);
  
  return `
    <svg viewBox="0 0 32 32">
      <circle class="knob-track" cx="16" cy="16" r="${radius}" 
        stroke-dasharray="${circumference * 0.75} ${circumference}"
        stroke-dashoffset="0"
        transform="rotate(${startAngle} 16 16)"/>
      <circle class="knob-value ${className}" cx="16" cy="16" r="${radius}"
        stroke-dasharray="${circumference * 0.75} ${circumference}"
        stroke-dashoffset="${circumference * 0.75 * (1 - value)}"
        transform="rotate(${startAngle} 16 16)"/>
    </svg>
  `;
}

// Check if channel is linked
function isLinked(trackIdx) {
  return linkedGroups.some(group => group.includes(trackIdx));
}

// Get linked partner
function getLinkedPartner(trackIdx) {
  for (const group of linkedGroups) {
    if (group.includes(trackIdx)) {
      return group.find(t => t !== trackIdx);
    }
  }
  return null;
}

// Toggle stereo link for a channel
function toggleLink(trackIdx) {
  // Find this track in inputTracks
  const trackInfo = inputTracks.find(t => t.idx === trackIdx);
  if (!trackInfo) return;
  
  // Find adjacent track
  const currentNum = parseInt(trackInfo.inputNum);
  const isEven = currentNum % 2 === 0;
  const partnerNum = isEven ? currentNum - 1 : currentNum + 1;
  const partnerInfo = inputTracks.find(t => t.inputNum === String(partnerNum));
  
  if (!partnerInfo) return;
  
  // Check if already linked
  const existingGroupIdx = linkedGroups.findIndex(g => g.includes(trackIdx));
  
  if (existingGroupIdx >= 0) {
    // Unlink
    linkedGroups.splice(existingGroupIdx, 1);
  } else {
    // Link
    linkedGroups.push([trackIdx, partnerInfo.idx]);
  }
  
  rebuildMixer();
}

// Build output channel strip (master or monitor output)
function buildOutputChannel(idx, name, color, busType) {
  const ch = document.createElement("div");
  ch.className = "channel output-channel";
  ch.dataset.trackIdx = idx;
  ch.dataset.type = "output";
  ch.dataset.busType = busType;

  const displayName = busType === "master" ? "üîä MAIN" : `üì¢ ${name}`;

  ch.innerHTML = `
    <div class="colorbar" style="background: ${busType === 'master' ? '#ff453a' : '#30d158'}"></div>
    <div class="track-name output-name">${displayName}</div>
    <button class="fx-btn output-fx" onclick="openOutputFxPanel(${idx}, '${busType}', '${name}')">EQ</button>
    <div class="fader-section">
      <div class="fader">
        <div class="meter-container">
          <div class="meter"><div class="meter-fill" data-meter="l"></div></div>
          <div class="meter"><div class="meter-fill" data-meter="r"></div></div>
        </div>
        <div class="fader-handle" data-fader="${idx}"></div>
      </div>
      <div class="fader-db" data-db="${idx}">0.0</div>
    </div>
    <div class="buttons-row">
      <button class="btn btn-mute" data-mute="${idx}">M</button>
    </div>
  `;

  // Setup fader drag
  const handle = ch.querySelector(".fader-handle");
  const faderEl = ch.querySelector(".fader");
  
  if (busType === "master") {
    setupMasterFaderDrag(handle, faderEl);
  } else {
    setupFaderDrag(handle, faderEl, idx);
  }

  // Setup mute button
  ch.querySelector(".btn-mute").onclick = () => {
    if (busType === "master") {
      wwr_req(`SET/MASTER/MUTE/-1`);
    } else {
      wwr_req(`SET/TRACK/${idx}/MUTE/-1`);
    }
  };

  return ch;
}

// Master fader drag
function setupMasterFaderDrag(handle, faderEl) {
  let startY, startTop;
  
  function start(e) {
    e.preventDefault();
    startY = e.touches ? e.touches[0].clientY : e.clientY;
    startTop = parseInt(handle.style.top) || 0;
    
    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", stop);
    document.addEventListener("touchmove", move, { passive: false });
    document.addEventListener("touchend", stop);
  }
  
  function move(e) {
    e.preventDefault();
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    const faderHeight = faderEl.clientHeight - handle.clientHeight;
    let newTop = startTop + (y - startY);
    newTop = Math.max(0, Math.min(faderHeight, newTop));
    
    const pct = 1 - (newTop / faderHeight);
    const db = (pct * 84) - 60;
    const vol = dbToVol(db);
    
    wwr_req(`SET/MASTER/VOL/${vol.toFixed(8)}`);
  }
  
  function stop() {
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", stop);
    document.removeEventListener("touchmove", move);
    document.removeEventListener("touchend", stop);
  }
  
  handle.addEventListener("mousedown", start);
  handle.addEventListener("touchstart", start, { passive: false });
}

// Build channel strip
function buildChannel(idx, name, color, type = "input", inputNum = null) {
  const ch = document.createElement("div");
  ch.className = "channel";
  ch.dataset.trackIdx = idx;
  ch.dataset.type = type;
  if (inputNum) ch.dataset.inputNum = inputNum;
  
  const linked = isLinked(idx);
  if (linked) ch.classList.add("linked");

  // Get custom name or default
  const trackNum = inputNum || "";
  const customName = customNames[trackNum] || name.replace(/^(IN|M\d+)\//, "").replace("VERB", "üîä Reverb");

  ch.innerHTML = `
    <div class="colorbar" style="background: ${color}"></div>
    <div class="track-name" data-track-num="${trackNum}" onclick="editTrackName(this, '${trackNum}')">${customName}</div>
    ${type === "input" ? `
    <div class="link-btn ${linked ? 'active' : ''}" onclick="toggleLink(${idx})" title="Stereo Link">üîó</div>
    <div class="sends-section">
      <div class="send-row">
        <span class="send-label">RV</span>
        <div class="send-knob-container">
          <button class="knob reverb" data-param="reverb" data-track="${idx}" data-input-num="${inputNum}" onclick="openKnobPopup(this)">
            ${createKnobSVG(0, "reverb")}
            <span class="knob-text">0</span>
          </button>
        </div>
      </div>
      ${monitorPrefixes.map((prefix, i) => `
      <div class="send-row" data-show-layer="foh">
        <span class="send-label">${prefix}</span>
        <div class="send-knob-container">
          <button class="knob mon${i+1}" data-param="${prefix.toLowerCase()}" data-track="${idx}" data-input-num="${inputNum}" onclick="openKnobPopup(this)">
            ${createKnobSVG(0, `mon${(i % 4) + 1}`)}
            <span class="knob-text">0</span>
          </button>
        </div>
      </div>
      `).join('')}
    </div>
    <button class="fx-btn" onclick="openFxPanel(${idx})">FX</button>
    <div class="pan-section">
      <button class="knob pan" data-param="pan" data-track="${idx}" onclick="openKnobPopup(this)">
        ${createKnobSVG(0.5, "pan")}
        <span class="knob-text">C</span>
      </button>
    </div>
    ` : ""}
    <div class="fader-section">
      <div class="fader">
        <div class="meter-container">
          <div class="meter"><div class="meter-fill" data-meter="l"></div></div>
          <div class="meter"><div class="meter-fill" data-meter="r"></div></div>
        </div>
        <div class="fader-handle" data-fader="${idx}"></div>
      </div>
      <div class="fader-db" data-db="${idx}">0.0</div>
    </div>
    <div class="buttons-row">
      <button class="btn btn-mute" data-mute="${idx}">M</button>
      <button class="btn btn-solo" data-solo="${idx}">S</button>
    </div>
  `;

  // Setup fader drag
  const handle = ch.querySelector(".fader-handle");
  const faderEl = ch.querySelector(".fader");
  setupFaderDrag(handle, faderEl, idx);

  // Knobs are now buttons with onclick - no drag setup needed

  // Setup mute/solo buttons
  ch.querySelector(".btn-mute").onclick = () => {
    wwr_req(`SET/TRACK/${idx}/MUTE/-1`);
    // Also mute linked channel
    const partner = getLinkedPartner(idx);
    if (partner) wwr_req(`SET/TRACK/${partner}/MUTE/-1`);
  };
  
  ch.querySelector(".btn-solo").onclick = () => {
    wwr_req(`SET/TRACK/${idx}/SOLO/-1`);
    // Also solo linked channel
    const partner = getLinkedPartner(idx);
    if (partner) wwr_req(`SET/TRACK/${partner}/SOLO/-1`);
  };

  return ch;
}

// Fader drag handling
function setupFaderDrag(handle, faderEl, trackIdx) {
  let startY, startTop;
  
  function start(e) {
    e.preventDefault();
    startY = e.touches ? e.touches[0].clientY : e.clientY;
    startTop = parseInt(handle.style.top) || 0;
    
    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", stop);
    document.addEventListener("touchmove", move, { passive: false });
    document.addEventListener("touchend", stop);
  }
  
  function move(e) {
    e.preventDefault();
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    const faderHeight = faderEl.clientHeight - handle.clientHeight;
    let newTop = startTop + (y - startY);
    newTop = Math.max(0, Math.min(faderHeight, newTop));
    
    // Convert position to dB
    const pct = 1 - (newTop / faderHeight);
    const db = (pct * 84) - 60; // Range: -60 to +24
    const vol = dbToVol(db);
    
    wwr_req(`SET/TRACK/${trackIdx}/VOL/${vol.toFixed(8)}`);
    
    // Also move linked channel
    const partner = getLinkedPartner(trackIdx);
    if (partner) {
      wwr_req(`SET/TRACK/${partner}/VOL/${vol.toFixed(8)}`);
    }
  }
  
  function stop() {
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", stop);
    document.removeEventListener("touchmove", move);
    document.removeEventListener("touchend", stop);
  }
  
  handle.addEventListener("mousedown", start);
  handle.addEventListener("touchstart", start, { passive: false });
}

// Open popup for send knobs (reverb, monitors, pan) - triggered by button click
function openKnobPopup(knob) {
  const param = knob.dataset.param;
  const trackIdx = parseInt(knob.dataset.track);
  const inputNum = knob.dataset.inputNum;
  const label = param === "pan" ? "Pan" : 
                param === "reverb" ? "Reverb" : 
                param.toUpperCase();
  openSendPopupFader(knob, trackIdx, inputNum, param, label);
}

// Popup fader for send knobs (reverb, monitors, pan)
function openSendPopupFader(knob, trackIdx, inputNum, param, label) {
  popupFaderKnob = knob;
  popupFaderTrackIdx = trackIdx;
  
  if (popupFaderTimeout) clearTimeout(popupFaderTimeout);
  
  const value = parseFloat(knob.dataset.value) || (param === "pan" ? 0.5 : 0);
  
  document.getElementById("popup-fader-label").textContent = label;
  document.getElementById("popup-fader-overlay").classList.add("show");
  document.getElementById("popup-fader-overlay").dataset.param = param;
  document.getElementById("popup-fader-overlay").dataset.inputNum = inputNum || "";
  document.getElementById("popup-fader-overlay").dataset.isSend = "true";
  
  updateSendPopupDisplay(value, param);
  setupSendPopupDrag(trackIdx, inputNum, param);
  resetPopupFaderTimeout();
}

function updateSendPopupDisplay(value, param) {
  const track = document.getElementById("popup-fader-track");
  const fill = document.getElementById("popup-fader-fill");
  const handle = document.getElementById("popup-fader-handle");
  const valueDisplay = document.getElementById("popup-fader-value");
  
  const trackHeight = track.clientHeight - handle.clientHeight;
  const top = trackHeight * (1 - value);
  
  handle.style.top = top + "px";
  fill.style.height = (value * 100) + "%";
  
  if (param === "pan") {
    let panText = "C";
    if (value < 0.48) panText = Math.round((0.5 - value) * 200) + "L";
    else if (value > 0.52) panText = Math.round((value - 0.5) * 200) + "R";
    valueDisplay.textContent = panText;
  } else {
    valueDisplay.textContent = Math.round(value * 100) + "%";
  }
}

function setupSendPopupDrag(trackIdx, inputNum, param) {
  const track = document.getElementById("popup-fader-track");
  const handle = document.getElementById("popup-fader-handle");
  
  function getValueFromY(y) {
    const rect = track.getBoundingClientRect();
    const trackHeight = track.clientHeight - handle.clientHeight;
    const relY = y - rect.top - (handle.clientHeight / 2);
    return 1 - Math.max(0, Math.min(1, relY / trackHeight));
  }
  
  function update(y) {
    resetPopupFaderTimeout();
    const value = getValueFromY(y);
    updateSendPopupDisplay(value, param);
    
    if (popupFaderKnob) {
      popupFaderKnob.dataset.value = value;
      const vol = value * value;
      
      if (param === "pan") {
        const panVal = (value - 0.5) * 2;
        wwr_req(`SET/TRACK/${trackIdx}/PAN/${panVal.toFixed(4)}`);
        let panText = "C";
        if (value < 0.48) panText = Math.round((0.5 - value) * 200) + "L";
        else if (value > 0.52) panText = Math.round((value - 0.5) * 200) + "R";
        popupFaderKnob.innerHTML = createKnobSVG(value, "pan") + `<span class="knob-text">${panText}</span>`;
      } else if (param === "reverb") {
        wwr_req(`SET/TRACK/${trackIdx}/SEND/0/VOL/${vol.toFixed(4)}`);
        updateKnob(popupFaderKnob, value);
      } else if (param.startsWith("m")) {
        const monKey = param.toUpperCase();
        const monIdx = inputToMonitorMap[monKey]?.[inputNum];
        if (monIdx) wwr_req(`SET/TRACK/${monIdx}/VOL/${vol.toFixed(4)}`);
        updateKnob(popupFaderKnob, value);
      }
    }
  }
  
  function start(e) {
    e.preventDefault();
    update(e.touches ? e.touches[0].clientY : e.clientY);
    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", stop);
    document.addEventListener("touchmove", move, { passive: false });
    document.addEventListener("touchend", stop);
  }
  
  function move(e) {
    e.preventDefault();
    update(e.touches ? e.touches[0].clientY : e.clientY);
  }
  
  function stop() {
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", stop);
    document.removeEventListener("touchmove", move);
    document.removeEventListener("touchend", stop);
  }
  
  track.onmousedown = start;
  track.ontouchstart = start;
}

function updateKnob(knob, value) {
  knob.dataset.value = value;
  knob.innerHTML = createKnobSVG(value, knob.classList.contains("reverb") ? "reverb" : 
                                        knob.classList.contains("mon1") ? "mon1" : "mon2") +
                   `<span class="knob-text">${Math.round(value * 100)}</span>`;
}

// FX Panel
function openFxPanel(trackIdx) {
  activeFxChannel = trackIdx;
  const track = tracks[trackIdx];
  if (!track) return;
  
  document.getElementById("fx-panel-title").textContent = track.name + " - FX";
  
  const content = document.getElementById("fx-panel-content");
  content.innerHTML = `
    <!-- Gate Section -->
    <div class="fx-section" data-fx="gate">
      <div class="fx-section-header">
        <span class="fx-section-title">üöß Gate</span>
        <button class="fx-bypass" data-fx-idx="0" onclick="toggleFxBypass(${trackIdx}, 0)">ON</button>
      </div>
      <div class="fx-params">
        <div class="fx-param">
          <div class="fx-param-label">Thresh</div>
          <button class="fx-param-knob" data-fx-idx="0" data-param-idx="0" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.5)}
          </button>
          <div class="fx-param-value">-30 dB</div>
        </div>
        <div class="fx-param">
          <div class="fx-param-label">Attack</div>
          <button class="fx-param-knob" data-fx-idx="0" data-param-idx="1" data-default="0.006" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.006)}
          </button>
          <div class="fx-param-value">0.6 ms</div>
        </div>
        <div class="fx-param">
          <div class="fx-param-label">Hold</div>
          <button class="fx-param-knob" data-fx-idx="0" data-param-idx="4" data-default="0" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0)}
          </button>
          <div class="fx-param-value">0 ms</div>
        </div>
        <div class="fx-param">
          <div class="fx-param-label">Release</div>
          <button class="fx-param-knob" data-fx-idx="0" data-param-idx="2" data-default="0.02" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.02)}
          </button>
          <div class="fx-param-value">20 ms</div>
        </div>
      </div>
      <div class="gate-meter" data-gate-meter="${trackIdx}">
        <div class="gate-meter-bg"></div>
        <div class="gate-meter-fill"></div>
        <span class="gate-meter-label">GATE CLOSED</span>
      </div>
    </div>
    
    <!-- Compressor Section -->
    <div class="fx-section" data-fx="comp">
      <div class="fx-section-header">
        <span class="fx-section-title">üîä Compressor</span>
        <button class="fx-bypass" data-fx-idx="1" onclick="toggleFxBypass(${trackIdx}, 1)">ON</button>
      </div>
      <div class="fx-params">
        <div class="fx-param">
          <div class="fx-param-label">Thresh</div>
          <button class="fx-param-knob" data-fx-idx="1" data-param-idx="0" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.5)}
          </button>
          <div class="fx-param-value">-18 dB</div>
        </div>
        <div class="fx-param">
          <div class="fx-param-label">Ratio</div>
          <button class="fx-param-knob" data-fx-idx="1" data-param-idx="1" data-default="0.0303" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.0303)}
          </button>
          <div class="fx-param-value">4:1</div>
        </div>
        <div class="fx-param">
          <div class="fx-param-label">Attack</div>
          <button class="fx-param-knob" data-fx-idx="1" data-param-idx="2" data-default="0.006" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.006)}
          </button>
          <div class="fx-param-value">0.6 ms</div>
        </div>
        <div class="fx-param">
          <div class="fx-param-label">Release</div>
          <button class="fx-param-knob" data-fx-idx="1" data-param-idx="3" data-default="0.02" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.02)}
          </button>
          <div class="fx-param-value">20 ms</div>
        </div>
      </div>
      <div class="gr-meter-container" data-gr-meter="${trackIdx}">
        <div class="gr-meter-header">
          <span class="gr-meter-title">Gain Reduction</span>
          <span class="gr-meter-value">0 dB</span>
        </div>
        <div class="gr-meter">
          <div class="gr-meter-fill"></div>
          <div class="gr-meter-scale">
            <div class="gr-meter-tick"></div>
            <div class="gr-meter-tick"></div>
            <div class="gr-meter-tick"></div>
            <div class="gr-meter-tick"></div>
            <div class="gr-meter-tick"></div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- EQ Section -->
    <div class="fx-section" data-fx="eq">
      <div class="fx-section-header">
        <span class="fx-section-title">üìä EQ</span>
        <button class="fx-bypass" data-fx-idx="2" onclick="toggleFxBypass(${trackIdx}, 2)">ON</button>
      </div>
      <div class="fx-params">
        <div class="fx-param eq-band">
          <div class="fx-param-label">HPF</div>
          <button class="fx-param-knob" data-fx-idx="2" data-param-idx="12" data-default="0.1414" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.1414)}
          </button>
          <div class="fx-param-value">20 Hz</div>
          <div class="eq-freq">High Pass</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">Low</div>
          <button class="fx-param-knob" data-fx-idx="2" data-param-idx="1" data-default="0.5" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.5)}
          </button>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">Low Shelf</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">Lo-Mid</div>
          <button class="fx-param-knob" data-fx-idx="2" data-param-idx="4" data-default="0.5" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.5)}
          </button>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">Band 2</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">Hi-Mid</div>
          <button class="fx-param-knob" data-fx-idx="2" data-param-idx="7" data-default="0.5" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.5)}
          </button>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">Band 3</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">High</div>
          <button class="fx-param-knob" data-fx-idx="2" data-param-idx="10" data-default="0.5" onclick="openFxKnobPopup(this, ${trackIdx})">
            ${createKnobSVG(0.5)}
          </button>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">High Shelf</div>
        </div>
      </div>
      <div class="eq-graph-container">
        <div class="eq-graph" id="eq-graph">
          <svg viewBox="0 0 300 100" preserveAspectRatio="none">
            <defs>
              <linearGradient id="eq-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stop-color="#4a9eff" stop-opacity="0.6"/>
                <stop offset="100%" stop-color="#4a9eff" stop-opacity="0"/>
              </linearGradient>
            </defs>
            <line class="eq-grid-line" x1="0" y1="25" x2="300" y2="25"/>
            <line class="eq-grid-line-zero" x1="0" y1="50" x2="300" y2="50"/>
            <line class="eq-grid-line" x1="0" y1="75" x2="300" y2="75"/>
            <path class="eq-curve-fill" id="eq-curve-fill"/>
            <path class="eq-curve" id="eq-curve"/>
          </svg>
          <div class="eq-db-labels">
            <span class="eq-db-label">+12</span>
            <span class="eq-db-label">0</span>
            <span class="eq-db-label">-12</span>
          </div>
        </div>
        <div class="eq-freq-labels">
          <span class="eq-freq-label">20</span>
          <span class="eq-freq-label">100</span>
          <span class="eq-freq-label">1k</span>
          <span class="eq-freq-label">10k</span>
          <span class="eq-freq-label">20k</span>
        </div>
      </div>
    </div>
  `;
  
  // FX knobs are now buttons with onclick - no additional setup needed
  
  // Request FX parameters - poll them along with track data
  // FX params are included in TRACK response when FX is present
  
  document.getElementById("fx-overlay").classList.add("show");
  
  // Request current FX values from Reaper
  requestFxValues(trackIdx);
  
  // Initial EQ curve draw
  setTimeout(updateEqGraph, 100);
}

function closeFxPanel() {
  document.getElementById("fx-overlay").classList.remove("show");
  activeFxChannel = null;
  activeFxType = null;
}

// Open EQ-only panel for output channels (master/monitor outputs)
function openOutputFxPanel(trackIdx, busType, name) {
  activeFxChannel = trackIdx;
  activeFxType = "output";
  
  const displayName = busType === "master" ? "Main Output" : name;
  document.getElementById("fx-panel-title").textContent = displayName + " - EQ";
  
  // Monitor outputs only have ReaEQ at FX slot 0
  const fxIdx = 0;
  
  const content = document.getElementById("fx-panel-content");
  content.innerHTML = `
    <!-- EQ Section for Output -->
    <div class="fx-section" data-fx="eq">
      <div class="fx-section-header">
        <span class="fx-section-title">üìä Output EQ</span>
        <button class="fx-bypass" data-fx-idx="${fxIdx}" onclick="toggleFxBypass(${trackIdx}, ${fxIdx})">ON</button>
      </div>
      <div class="fx-params">
        <div class="fx-param eq-band">
          <div class="fx-param-label">HPF</div>
          <div class="fx-param-knob" data-fx-idx="${fxIdx}" data-param-idx="12" data-default="0.1414">
            ${createKnobSVG(0.1414)}
          </div>
          <div class="fx-param-value">20 Hz</div>
          <div class="eq-freq">High Pass</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">Low</div>
          <div class="fx-param-knob" data-fx-idx="${fxIdx}" data-param-idx="1" data-default="0.5">
            ${createKnobSVG(0.5)}
          </div>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">Low Shelf</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">Lo-Mid</div>
          <div class="fx-param-knob" data-fx-idx="${fxIdx}" data-param-idx="4" data-default="0.5">
            ${createKnobSVG(0.5)}
          </div>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">Band 2</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">Hi-Mid</div>
          <div class="fx-param-knob" data-fx-idx="${fxIdx}" data-param-idx="7" data-default="0.5">
            ${createKnobSVG(0.5)}
          </div>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">Band 3</div>
        </div>
        <div class="fx-param eq-band">
          <div class="fx-param-label">High</div>
          <div class="fx-param-knob" data-fx-idx="${fxIdx}" data-param-idx="10" data-default="0.5">
            ${createKnobSVG(0.5)}
          </div>
          <div class="fx-param-value">0.0 dB</div>
          <div class="eq-freq">High Shelf</div>
        </div>
      </div>
    </div>
  `;
  
  // FX knobs are now buttons with onclick - just need to add trackIdx attribute
  content.querySelectorAll(".fx-param-knob").forEach(knob => {
    knob.onclick = () => openFxKnobPopup(knob, trackIdx);
  });
  
  document.getElementById("fx-overlay").classList.add("show");
  
  // Request current EQ values
  requestOutputFxValues(trackIdx);
}

function requestOutputFxValues(trackIdx) {
  if (oscWs && oscWs.readyState === WebSocket.OPEN) {
    oscWs.send(JSON.stringify({
      type: 'fxReadOutput',
      trackIdx: trackIdx
    }));
  }
}

function toggleFxBypass(trackIdx, fxIdx) {
  // Send bypass toggle via WebSocket to ReaScript
  sendFxBypass(trackIdx, fxIdx);
  const partner = getLinkedPartner(trackIdx);
  if (partner) {
    sendFxBypass(partner, fxIdx);
  }
}

// Popup Fader State
let popupFaderKnob = null;
let popupFaderTrackIdx = null;
let popupFaderTimeout = null;

function openPopupFader(knob, trackIdx, label, fxIdx, paramIdx) {
  popupFaderKnob = knob;
  popupFaderTrackIdx = trackIdx;
  
  // Clear any existing timeout
  if (popupFaderTimeout) clearTimeout(popupFaderTimeout);
  
  const value = parseFloat(knob.dataset.value) || 0.5;
  
  document.getElementById("popup-fader-label").textContent = label;
  document.getElementById("popup-fader-overlay").classList.add("show");
  document.getElementById("popup-fader-overlay").dataset.fxIdx = fxIdx;
  document.getElementById("popup-fader-overlay").dataset.paramIdx = paramIdx;
  
  updatePopupFaderDisplay(value, fxIdx, paramIdx);
  setupPopupFaderDrag();
  
  // Auto-close after 5 seconds of inactivity
  resetPopupFaderTimeout();
}

function resetPopupFaderTimeout() {
  if (popupFaderTimeout) clearTimeout(popupFaderTimeout);
  popupFaderTimeout = setTimeout(closePopupFader, 5000);
}

function closePopupFader(e) {
  if (e && e.target && e.target.closest('.popup-fader')) return;
  document.getElementById("popup-fader-overlay").classList.remove("show");
  popupFaderKnob = null;
  popupFaderTrackIdx = null;
  if (popupFaderTimeout) clearTimeout(popupFaderTimeout);
}

function updatePopupFaderDisplay(value, fxIdx, paramIdx) {
  const track = document.getElementById("popup-fader-track");
  const fill = document.getElementById("popup-fader-fill");
  const handle = document.getElementById("popup-fader-handle");
  const valueDisplay = document.getElementById("popup-fader-value");
  
  const trackHeight = track.clientHeight - handle.clientHeight;
  const top = trackHeight * (1 - value);
  
  handle.style.top = top + "px";
  fill.style.height = (value * 100) + "%";
  valueDisplay.textContent = formatFxValue(parseInt(fxIdx), parseInt(paramIdx), value);
}

function setupPopupFaderDrag() {
  const track = document.getElementById("popup-fader-track");
  const handle = document.getElementById("popup-fader-handle");
  
  function getValueFromY(y) {
    const rect = track.getBoundingClientRect();
    const trackHeight = track.clientHeight - handle.clientHeight;
    const relY = y - rect.top - (handle.clientHeight / 2);
    const pct = 1 - Math.max(0, Math.min(1, relY / trackHeight));
    return pct;
  }
  
  function update(y) {
    resetPopupFaderTimeout();
    const value = getValueFromY(y);
    const fxIdx = document.getElementById("popup-fader-overlay").dataset.fxIdx;
    const paramIdx = document.getElementById("popup-fader-overlay").dataset.paramIdx;
    
    updatePopupFaderDisplay(value, fxIdx, paramIdx);
    
    // Update the source knob
    if (popupFaderKnob) {
      popupFaderKnob.dataset.value = value;
      popupFaderKnob.innerHTML = createKnobSVG(value);
      
      const paramContainer = popupFaderKnob.closest('.fx-param');
      const valueEl = paramContainer?.querySelector('.fx-param-value');
      if (valueEl) valueEl.textContent = formatFxValue(parseInt(fxIdx), parseInt(paramIdx), value);
    }
    
    // Send to Reaper
    if (popupFaderTrackIdx !== null) {
      sendFxCommand(popupFaderTrackIdx, parseInt(fxIdx), parseInt(paramIdx), value);
      const partner = getLinkedPartner(popupFaderTrackIdx);
      if (partner) sendFxCommand(partner, parseInt(fxIdx), parseInt(paramIdx), value);
    }
  }
  
  function start(e) {
    e.preventDefault();
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    update(y);
    
    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", stop);
    document.addEventListener("touchmove", move, { passive: false });
    document.addEventListener("touchend", stop);
  }
  
  function move(e) {
    e.preventDefault();
    const y = e.touches ? e.touches[0].clientY : e.clientY;
    update(y);
  }
  
  function stop() {
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", stop);
    document.removeEventListener("touchmove", move);
    document.removeEventListener("touchend", stop);
  }
  
  // Remove old listeners
  track.onmousedown = start;
  track.ontouchstart = start;
}

// EQ Frequency parameter mapping for ReaEQ
// Band 2 (Lo-Mid): freq=3, gain=4
// Band 3 (Hi-Mid): freq=6, gain=7
const EQ_BAND_FREQ_MAP = {
  '4': { freqParam: 3, name: 'Lo-Mid', minFreq: 100, maxFreq: 2000 },
  '7': { freqParam: 6, name: 'Hi-Mid', minFreq: 800, maxFreq: 8000 }
};

// Current frequency values for range limiting
let currentEqFreqs = { loMid: 500, hiMid: 2500 };

// Open popup for FX knobs - triggered by button click
function openFxKnobPopup(knob, trackIdx) {
  const fxIdx = knob.dataset.fxIdx;
  const paramIdx = knob.dataset.paramIdx;
  const label = knob.closest('.fx-param')?.querySelector('.fx-param-label')?.textContent || 'Parameter';
  
  // Check if this is an EQ band with frequency control
  const isEqBand = (fxIdx === '2' || fxIdx === '0') && EQ_BAND_FREQ_MAP[paramIdx];
  
  openPopupFader(knob, trackIdx, label, fxIdx, paramIdx);
  
  // Show frequency slider for parametric EQ bands
  const freqContainer = document.getElementById('popup-freq-container');
  if (isEqBand) {
    const bandInfo = EQ_BAND_FREQ_MAP[paramIdx];
    freqContainer.classList.add('show');
    freqContainer.dataset.freqParam = bandInfo.freqParam;
    freqContainer.dataset.bandName = bandInfo.name;
    
    // Calculate dynamic range limits
    let minFreq = bandInfo.minFreq;
    let maxFreq = bandInfo.maxFreq;
    
    // Limit Lo-Mid max to below Hi-Mid current freq
    if (paramIdx === '4' && currentEqFreqs.hiMid) {
      maxFreq = Math.min(maxFreq, currentEqFreqs.hiMid * 0.8);
    }
    // Limit Hi-Mid min to above Lo-Mid current freq
    if (paramIdx === '7' && currentEqFreqs.loMid) {
      minFreq = Math.max(minFreq, currentEqFreqs.loMid * 1.25);
    }
    
    freqContainer.dataset.minFreq = minFreq;
    freqContainer.dataset.maxFreq = maxFreq;
    
    // Update range labels
    document.getElementById('popup-freq-min').textContent = formatFreq(minFreq);
    document.getElementById('popup-freq-max').textContent = formatFreq(maxFreq);
    
    // Get current frequency value and set slider position
    const currentFreq = paramIdx === '4' ? currentEqFreqs.loMid : currentEqFreqs.hiMid;
    const normalizedFreq = freqToNormalized(currentFreq, minFreq, maxFreq);
    updateFreqSliderDisplay(normalizedFreq, currentFreq);
    
    setupFreqSliderDrag(trackIdx, fxIdx, bandInfo.freqParam, paramIdx);
  } else {
    freqContainer.classList.remove('show');
  }
}

// Format frequency for display
function formatFreq(freq) {
  if (freq >= 1000) {
    return (freq / 1000).toFixed(1) + ' kHz';
  }
  return Math.round(freq) + ' Hz';
}

// Convert frequency to normalized 0-1 value (logarithmic)
function freqToNormalized(freq, minFreq, maxFreq) {
  const logMin = Math.log10(minFreq);
  const logMax = Math.log10(maxFreq);
  const logFreq = Math.log10(freq);
  return (logFreq - logMin) / (logMax - logMin);
}

// Convert normalized 0-1 to frequency (logarithmic)
function normalizedToFreq(normalized, minFreq, maxFreq) {
  const logMin = Math.log10(minFreq);
  const logMax = Math.log10(maxFreq);
  const logFreq = logMin + normalized * (logMax - logMin);
  return Math.pow(10, logFreq);
}

// Update frequency slider display
function updateFreqSliderDisplay(normalized, freq) {
  const track = document.getElementById('popup-freq-track');
  const handle = document.getElementById('popup-freq-handle');
  const fill = document.getElementById('popup-freq-fill');
  const valueDisplay = document.getElementById('popup-freq-value');
  
  const trackWidth = track.clientWidth - handle.clientWidth;
  const left = normalized * trackWidth + (handle.clientWidth / 2);
  
  handle.style.left = left + 'px';
  fill.style.width = (normalized * 100) + '%';
  valueDisplay.textContent = formatFreq(freq);
}

// Setup frequency slider drag
function setupFreqSliderDrag(trackIdx, fxIdx, freqParam, gainParam) {
  const track = document.getElementById('popup-freq-track');
  const handle = document.getElementById('popup-freq-handle');
  const container = document.getElementById('popup-freq-container');
  
  function getValueFromX(x) {
    const rect = track.getBoundingClientRect();
    const trackWidth = track.clientWidth - handle.clientWidth;
    const relX = x - rect.left - (handle.clientWidth / 2);
    return Math.max(0, Math.min(1, relX / trackWidth));
  }
  
  function update(x) {
    resetPopupFaderTimeout();
    const normalized = getValueFromX(x);
    const minFreq = parseFloat(container.dataset.minFreq);
    const maxFreq = parseFloat(container.dataset.maxFreq);
    const freq = normalizedToFreq(normalized, minFreq, maxFreq);
    
    updateFreqSliderDisplay(normalized, freq);
    
    // Update stored frequency
    if (gainParam === '4') {
      currentEqFreqs.loMid = freq;
    } else if (gainParam === '7') {
      currentEqFreqs.hiMid = freq;
    }
    
    // Convert frequency to ReaEQ normalized value (20Hz-20kHz log scale)
    const reaEqNorm = Math.log10(freq / 20) / Math.log10(1000);
    
    // Send to Reaper
    sendFxCommand(trackIdx, parseInt(fxIdx), freqParam, reaEqNorm);
    const partner = getLinkedPartner(trackIdx);
    if (partner) sendFxCommand(partner, parseInt(fxIdx), freqParam, reaEqNorm);
    
    // Update EQ graph
    updateEqGraph();
  }
  
  function start(e) {
    e.preventDefault();
    update(e.touches ? e.touches[0].clientX : e.clientX);
    document.addEventListener('mousemove', move);
    document.addEventListener('mouseup', stop);
    document.addEventListener('touchmove', move, { passive: false });
    document.addEventListener('touchend', stop);
  }
  
  function move(e) {
    e.preventDefault();
    update(e.touches ? e.touches[0].clientX : e.clientX);
  }
  
  function stop() {
    document.removeEventListener('mousemove', move);
    document.removeEventListener('mouseup', stop);
    document.removeEventListener('touchmove', move);
    document.removeEventListener('touchend', stop);
  }
  
  track.onmousedown = start;
  track.ontouchstart = start;
}

// Build layer tabs dynamically
function rebuildTabs() {
  const tabContainer = document.querySelector(".layer-tabs");
  tabContainer.innerHTML = `<button class="layer-tab ${currentLayer === 'foh' ? 'active' : ''}" data-layer="foh">FOH</button>`;
  
  const colors = ['#ff9500', '#30d158', '#5ac8fa', '#ff2d55', '#af52de', '#ffcc00'];
  
  monitorPrefixes.forEach((prefix, i) => {
    const colorClass = `mon${i + 1}`;
    tabContainer.innerHTML += `<button class="layer-tab ${colorClass} ${currentLayer === prefix.toLowerCase() ? 'active' : ''}" data-layer="${prefix.toLowerCase()}">${prefix}</button>`;
  });
  
  // Re-attach click handlers
  document.querySelectorAll(".layer-tab").forEach(tab => {
    tab.onclick = () => {
      document.querySelectorAll(".layer-tab").forEach(t => t.classList.remove("active"));
      tab.classList.add("active");
      currentLayer = tab.dataset.layer;
      rebuildMixer();
    };
  });
}

// Rebuild mixer based on current layer
function rebuildMixer() {
  const container = document.getElementById("mixer-container");
  container.innerHTML = "";
  
  let tracksToShow = [];
  let outputChannel = null;
  
  if (currentLayer === "foh") {
    tracksToShow = [...fohTracks];
    // Add master fader at end
    outputChannel = { type: "master", idx: 0, name: "MAIN", color: "#ff453a" };
  } else {
    // Find matching monitor bus (m1, m2, m3, etc.)
    const prefix = currentLayer.toUpperCase();
    tracksToShow = monitorBuses[prefix] || [];
    
    // Add monitor output fader at end
    const outputInfo = monitorOutputTracks[prefix];
    if (outputInfo) {
      outputChannel = { type: "monitor", idx: outputInfo.idx, name: outputInfo.name, color: outputInfo.color };
    }
  }
  
  // Sort tracks: numbers first, then special (VERB, REVERB)
  tracksToShow.sort((a, b) => {
    const numA = parseInt(a.inputNum) || 999;
    const numB = parseInt(b.inputNum) || 999;
    return numA - numB;
  });
  
  tracksToShow.forEach(t => {
    const channel = buildChannel(t.idx, t.name, t.color, t.type, t.inputNum);
    container.appendChild(channel);
  });
  
  // Add output channel at the end
  if (outputChannel) {
    const outCh = buildOutputChannel(outputChannel.idx, outputChannel.name, outputChannel.color, outputChannel.type);
    container.appendChild(outCh);
  }
}

// Extract channel number from track name
function getChannelNum(name) {
  const match = name.match(/\/(\d+)$/);
  return match ? match[1] : null;
}

// Handle Reaper replies
function wwr_onreply(data) {
  const lines = data.split("\n");
  let needsRebuild = false;
  
  lines.forEach(line => {
    const tok = line.split("\t");
    
    if (tok[0] === "TRACK") {
      const idx = parseInt(tok[1]);
      const name = tok[2];
      const flags = parseInt(tok[3]);
      const vol = parseFloat(tok[4]);
      const pan = parseFloat(tok[5]);
      const peak = parseInt(tok[6]) || 0;
      const peakR = parseInt(tok[7]) || 0;
      const color = colorFromReaper(tok[13]);
      
      // Categorize tracks on first encounter
      if (!tracks[idx]) {
        tracks[idx] = { name, color, vol };
        
        if (name === REVERB_TRACK_NAME) {
          reverbTrackIdx = idx;
          // Add reverb to FOH tracks
          fohTracks.push({ idx, name, color, type: "bus", inputNum: "REV" });
          needsRebuild = true;
        } else if (name.startsWith(INPUT_PREFIX)) {
          const inputNum = getChannelNum(name);
          const trackInfo = { idx, name, color, type: "input", inputNum };
          inputTracks.push(trackInfo);
          fohTracks.push(trackInfo);
          needsRebuild = true;
        } else if (name.match(/^MON \d+$/)) {
          // Monitor output bus (e.g., "MON 1", "MON 2")
          const monNum = name.match(/^MON (\d+)$/)[1];
          const prefix = "M" + monNum;
          monitorOutputTracks[prefix] = { idx, name, color };
          needsRebuild = true;
        } else {
          // Check for monitor bus pattern: M1/, M2/, M3/, etc.
          const monMatch = name.match(/^(M\d+)\//);
          if (monMatch) {
            const prefix = monMatch[1]; // "M1", "M2", etc.
            
            // Initialize bus if needed
            if (!monitorBuses[prefix]) {
              monitorBuses[prefix] = [];
              inputToMonitorMap[prefix] = {};
              if (!monitorPrefixes.includes(prefix)) {
                monitorPrefixes.push(prefix);
                monitorPrefixes.sort();
                rebuildTabs();
              }
            }
            
            const inputNum = name.includes("VERB") ? "VERB" : getChannelNum(name);
            monitorBuses[prefix].push({ idx, name, color, type: "monitor", inputNum });
            
            if (inputNum && inputNum !== "VERB") {
              inputToMonitorMap[prefix][inputNum] = idx;
            }
            needsRebuild = true;
          }
        }
      }
      
      // Update channel strip
      const channel = document.querySelector(`.channel[data-track-idx="${idx}"]`);
      if (channel) {
        // Update fader position
        const db = volToDb(vol);
        const handle = channel.querySelector(".fader-handle");
        const faderEl = channel.querySelector(".fader");
        if (handle && faderEl) {
          const faderHeight = faderEl.clientHeight - handle.clientHeight;
          const pct = (db + 60) / 84; // -60 to +24 range
          const top = faderHeight * (1 - Math.max(0, Math.min(1, pct)));
          handle.style.top = top + "px";
        }
        
        // Update dB display
        const dbDisplay = channel.querySelector(".fader-db");
        if (dbDisplay) {
          dbDisplay.textContent = formatDb(db);
        }
        
        // Update meters (peak values from Reaper are in 0.1 dB units)
        const meterL = channel.querySelector('[data-meter="l"]');
        const meterR = channel.querySelector('[data-meter="r"]');
        if (meterL && meterR) {
          // Convert peak to dB then to percentage (matching IEM mixer)
          const peakDbL = peak / 10;
          const peakDbR = (peakR || peak) / 10;
          const pctL = Math.max(0, Math.min(100, (peakDbL + 60) / 60 * 100));
          const pctR = Math.max(0, Math.min(100, (peakDbR + 60) / 60 * 100));
          meterL.style.height = pctL + "%";
          meterR.style.height = pctR + "%";
        }
        
        // Update mute state
        const muteBtn = channel.querySelector(".btn-mute");
        if (muteBtn) {
          if (flags & 8) muteBtn.classList.add("active");
          else muteBtn.classList.remove("active");
        }
        
        // Update solo state
        const soloBtn = channel.querySelector(".btn-solo");
        if (soloBtn) {
          if (flags & 16) soloBtn.classList.add("active");
          else soloBtn.classList.remove("active");
        }
        
        // Update pan knob
        const panKnob = channel.querySelector(".knob.pan");
        if (panKnob) {
          const panVal = (pan + 1) / 2; // Convert -1..+1 to 0..1
          panKnob.dataset.value = panVal;
          let panText = "C";
          if (panVal < 0.48) panText = Math.round((0.5 - panVal) * 200) + "L";
          else if (panVal > 0.52) panText = Math.round((panVal - 0.5) * 200) + "R";
          panKnob.innerHTML = createKnobSVG(panVal, "pan") + `<span class="knob-text">${panText}</span>`;
        }
      }
      
      // Update monitor send knobs in FOH view based on Mx/ track volumes
      if (currentLayer === "foh") {
        const monMatch = name.match(/^(M\d+)\//);
        if (monMatch && !name.includes("VERB")) {
          const prefix = monMatch[1];
          const inputNum = getChannelNum(name);
          const monIdx = monitorPrefixes.indexOf(prefix) + 1;
          if (inputNum && monIdx > 0) {
            const knob = document.querySelector(`.knob[data-param="${prefix.toLowerCase()}"][data-input-num="${inputNum}"]`);
            if (knob) {
              const knobVal = Math.sqrt(vol);
              updateKnob(knob, Math.min(1, knobVal));
            }
          }
        }
      }
    }
    
    // Handle FX parameter responses  
    // Format: FXPARM trackIdx fxIdx paramIdx value name
    if (tok[0] === "FXPARM" && activeFxChannel !== null) {
      const trackIdxResp = parseInt(tok[1]);
      if (trackIdxResp === activeFxChannel) {
        const fxIdx = parseInt(tok[2]);
        const paramIdx = parseInt(tok[3]);
        const value = parseFloat(tok[4]);
        // tok[5] is param name
        
        const knob = document.querySelector(
          `.fx-param-knob[data-fx-idx="${fxIdx}"][data-param-idx="${paramIdx}"]`
        );
        if (knob) {
          knob.dataset.value = value;
          knob.innerHTML = createKnobSVG(value);
          
          const paramContainer = knob.closest('.fx-param');
          const valueDisplay = paramContainer?.querySelector('.fx-param-value');
          if (valueDisplay) {
            valueDisplay.textContent = formatFxValue(fxIdx, paramIdx, value);
          }
        }
      }
    }
  });
  
  // Rebuild mixer once after initial track discovery
  if (needsRebuild && !initialized) {
    initialized = true;
    setTimeout(rebuildMixer, 100);
  }
}

// Close FX panel when clicking overlay
document.getElementById("fx-overlay").onclick = (e) => {
  if (e.target.id === "fx-overlay") {
    closeFxPanel();
  }
};

// Initial tab build
rebuildTabs();

// Request FX params via OSC when panel opens
function requestFxParams(trackIdx) {
  if (!oscConnected) return;
  
  // Request each FX param we care about
  const fxParams = [
    [0, [0, 4, 5, 6]],      // Gate
    [1, [0, 3, 4, 5]],      // Comp
    [2, [2, 6, 10, 14]]     // EQ gains
  ];
  
  fxParams.forEach(([fxIdx, params]) => {
    params.forEach(paramIdx => {
      sendOSC(`/track/${trackIdx}/fx/${fxIdx}/fxparam/${paramIdx}/value`, -1); // -1 = query
    });
  });
}

// EQ Graph - draw frequency response curve
function updateEqGraph() {
  const curvePath = document.getElementById('eq-curve');
  const fillPath = document.getElementById('eq-curve-fill');
  if (!curvePath || !fillPath) return;
  
  // Get current EQ values from knobs (fxIdx=2 for input EQ, fxIdx=0 for output EQ)
  const fxIdx = activeFxType === 'output' ? 0 : 2;
  
  // Get values: HPF(12), Low(1), LoMid(4), HiMid(7), High(10)
  const getKnobValue = (paramIdx) => {
    const knob = document.querySelector(`.fx-param-knob[data-fx-idx="${fxIdx}"][data-param-idx="${paramIdx}"]`);
    return parseFloat(knob?.dataset?.value) || parseFloat(knob?.dataset?.default) || 0.5;
  };
  
  const hpfVal = getKnobValue(12);
  const lowVal = getKnobValue(1);
  const loMidVal = getKnobValue(4);
  const hiMidVal = getKnobValue(7);
  const highVal = getKnobValue(10);
  
  // Convert normalized values to dB (-24 to +24)
  const lowDb = (lowVal - 0.5) * 48;
  const loMidDb = (loMidVal - 0.5) * 48;
  const hiMidDb = (hiMidVal - 0.5) * 48;
  const highDb = (highVal - 0.5) * 48;
  
  // HPF frequency (20Hz to 20kHz logarithmic)
  const hpfFreq = 20 * Math.pow(1000, hpfVal);
  
  // Use current frequencies for parametric bands
  const bands = [
    { freq: 100, db: lowDb, q: 0.7, type: 'lowshelf' },
    { freq: currentEqFreqs.loMid, db: loMidDb, q: 1.4 },
    { freq: currentEqFreqs.hiMid, db: hiMidDb, q: 1.4 },
    { freq: 8000, db: highDb, q: 0.7, type: 'highshelf' }
  ];
  
  // Generate curve points
  const width = 300;
  const height = 100;
  const points = [];
  const numPoints = 100;
  
  for (let i = 0; i <= numPoints; i++) {
    const x = (i / numPoints) * width;
    // Log frequency from 20Hz to 20kHz
    const freq = 20 * Math.pow(1000, i / numPoints);
    
    // Calculate combined response at this frequency
    let totalDb = 0;
    
    // HPF response (12dB/oct highpass)
    if (freq < hpfFreq * 2) {
      const ratio = freq / hpfFreq;
      if (ratio < 1) {
        totalDb += -24 * (1 - ratio);
      }
    }
    
    // Each EQ band
    bands.forEach(band => {
      const octaveDistance = Math.log2(freq / band.freq);
      let bandResponse = 0;
      
      if (band.type === 'lowshelf') {
        if (freq < band.freq) {
          bandResponse = band.db;
        } else {
          bandResponse = band.db * Math.exp(-Math.abs(octaveDistance) * 1.5);
        }
      } else if (band.type === 'highshelf') {
        if (freq > band.freq) {
          bandResponse = band.db;
        } else {
          bandResponse = band.db * Math.exp(-Math.abs(octaveDistance) * 1.5);
        }
      } else {
        // Parametric band
        const bandwidth = 1 / band.q;
        bandResponse = band.db * Math.exp(-Math.pow(octaveDistance / bandwidth, 2));
      }
      
      totalDb += bandResponse;
    });
    
    // Clamp to +/-24dB display range, map to Y
    totalDb = Math.max(-24, Math.min(24, totalDb));
    const y = height / 2 - (totalDb / 24) * (height / 2);
    points.push({ x, y });
  }
  
  // Create SVG path
  let d = `M ${points[0].x} ${points[0].y}`;
  for (let i = 1; i < points.length; i++) {
    d += ` L ${points[i].x} ${points[i].y}`;
  }
  curvePath.setAttribute('d', d);
  
  // Create fill path (closes to bottom)
  fillPath.setAttribute('d', d + ` L ${width} ${height} L 0 ${height} Z`);
}

// Override the popup fader update to also update EQ graph
const originalSetupPopupFaderDrag = setupPopupFaderDrag;
setupPopupFaderDrag = function() {
  const track = document.getElementById("popup-fader-track");
  const handle = document.getElementById("popup-fader-handle");
  
  function getValueFromY(y) {
    const rect = track.getBoundingClientRect();
    const trackHeight = track.clientHeight - handle.clientHeight;
    const relY = y - rect.top - (handle.clientHeight / 2);
    return 1 - Math.max(0, Math.min(1, relY / trackHeight));
  }
  
  function update(y) {
    resetPopupFaderTimeout();
    const value = getValueFromY(y);
    const fxIdx = document.getElementById("popup-fader-overlay").dataset.fxIdx;
    const paramIdx = document.getElementById("popup-fader-overlay").dataset.paramIdx;
    
    updatePopupFaderDisplay(value, fxIdx, paramIdx);
    
    if (popupFaderKnob) {
      popupFaderKnob.dataset.value = value;
      popupFaderKnob.innerHTML = createKnobSVG(value);
      
      const paramContainer = popupFaderKnob.closest('.fx-param');
      const valueEl = paramContainer?.querySelector('.fx-param-value');
      if (valueEl) valueEl.textContent = formatFxValue(parseInt(fxIdx), parseInt(paramIdx), value);
    }
    
    if (popupFaderTrackIdx !== null) {
      sendFxCommand(popupFaderTrackIdx, parseInt(fxIdx), parseInt(paramIdx), value);
      const partner = getLinkedPartner(popupFaderTrackIdx);
      if (partner) sendFxCommand(partner, parseInt(fxIdx), parseInt(paramIdx), value);
    }
    
    // Update EQ graph if this is an EQ param
    if ((fxIdx === '2' || fxIdx === '0') && [1, 4, 7, 10, 12].includes(parseInt(paramIdx))) {
      updateEqGraph();
    }
  }
  
  function start(e) {
    e.preventDefault();
    update(e.touches ? e.touches[0].clientY : e.clientY);
    document.addEventListener("mousemove", move);
    document.addEventListener("mouseup", stop);
    document.addEventListener("touchmove", move, { passive: false });
    document.addEventListener("touchend", stop);
  }
  
  function move(e) {
    e.preventDefault();
    update(e.touches ? e.touches[0].clientY : e.clientY);
  }
  
  function stop() {
    document.removeEventListener("mousemove", move);
    document.removeEventListener("mouseup", stop);
    document.removeEventListener("touchmove", move);
    document.removeEventListener("touchend", stop);
  }
  
  track.onmousedown = start;
  track.ontouchstart = start;
};

// Update EQ graph when FX values are received
const originalHandleFxValues = handleFxValues;
handleFxValues = function(data) {
  originalHandleFxValues(data);
  setTimeout(updateEqGraph, 50);
};

// Global FX state
let globalFxBypassed = false;

function toggleGlobalFx() {
  globalFxBypassed = !globalFxBypassed;
  const btn = document.getElementById('globalFxBtn');
  btn.classList.toggle('bypassed', globalFxBypassed);
  btn.textContent = globalFxBypassed ? 'FX OFF' : 'FX';
  
  // Toggle all FX on all input tracks
  inputTracks.forEach(t => {
    for (let fxIdx = 0; fxIdx <= 2; fxIdx++) {
      if (globalFxBypassed) {
        // Bypass (disable) all FX
        sendFxCommand(t.idx, fxIdx, -1, globalFxBypassed ? 0 : 1); // Special bypass command
      }
    }
  });
  
  // Send bypass command via OSC for all tracks
  if (oscWs && oscWs.readyState === WebSocket.OPEN) {
    inputTracks.forEach(t => {
      oscWs.send(JSON.stringify({
        type: 'globalFxBypass',
        trackIdx: t.idx,
        bypassed: globalFxBypassed
      }));
    });
  }
}

// Reset Menu Functions
function openResetMenu() {
  document.getElementById('reset-menu-overlay').classList.add('show');
}

function closeResetMenu(e) {
  if (e && e.target && !e.target.classList.contains('reset-menu-overlay')) return;
  document.getElementById('reset-menu-overlay').classList.remove('show');
}

function confirmReset(type) {
  const messages = {
    'faders': 'Reset all faders to unity (0 dB)?',
    'eq': 'Reset all EQs to flat?',
    'gates': 'Reset all gates to default?',
    'comps': 'Reset all compressors to default?',
    'all': 'Reset EVERYTHING to defaults?'
  };
  
  if (confirm(messages[type])) {
    performReset(type);
  }
  closeResetMenu();
}

function performReset(type) {
  const unityVol = dbToVol(0); // 0 dB = unity
  
  inputTracks.forEach(t => {
    const trackIdx = t.idx;
    const partner = getLinkedPartner(trackIdx);
    
    if (type === 'faders' || type === 'all') {
      wwr_req(`SET/TRACK/${trackIdx}/VOL/${unityVol.toFixed(8)}`);
      if (partner) wwr_req(`SET/TRACK/${partner}/VOL/${unityVol.toFixed(8)}`);
    }
    
    if (type === 'eq' || type === 'all') {
      // Reset EQ bands to flat (0.5 = 0dB)
      [1, 4, 7, 10].forEach(paramIdx => {
        sendFxCommand(trackIdx, 2, paramIdx, 0.5);
        if (partner) sendFxCommand(partner, 2, paramIdx, 0.5);
      });
      // Reset HPF to minimum (20Hz)
      sendFxCommand(trackIdx, 2, 12, 0);
      if (partner) sendFxCommand(partner, 2, 12, 0);
    }
    
    if (type === 'gates' || type === 'all') {
      // Reset gate: threshold=-60dB (0), attack=6ms (0.006), hold=0 (0), release=20ms (0.02)
      sendFxCommand(trackIdx, 0, 0, 0);     // Threshold
      sendFxCommand(trackIdx, 0, 1, 0.006); // Attack
      sendFxCommand(trackIdx, 0, 4, 0);     // Hold
      sendFxCommand(trackIdx, 0, 2, 0.02);  // Release
      if (partner) {
        sendFxCommand(partner, 0, 0, 0);
        sendFxCommand(partner, 0, 1, 0.006);
        sendFxCommand(partner, 0, 4, 0);
        sendFxCommand(partner, 0, 2, 0.02);
      }
    }
    
    if (type === 'comps' || type === 'all') {
      // Reset comp: threshold=0 (top), ratio=4:1 (0.0303), attack=6ms (0.006), release=20ms (0.02)
      sendFxCommand(trackIdx, 1, 0, 1);       // Threshold at max (no compression)
      sendFxCommand(trackIdx, 1, 1, 0.0303);  // Ratio 4:1
      sendFxCommand(trackIdx, 1, 2, 0.006);   // Attack
      sendFxCommand(trackIdx, 1, 3, 0.02);    // Release
      if (partner) {
        sendFxCommand(partner, 1, 0, 1);
        sendFxCommand(partner, 1, 1, 0.0303);
        sendFxCommand(partner, 1, 2, 0.006);
        sendFxCommand(partner, 1, 3, 0.02);
      }
    }
  });
}

// Request reverb send levels for all input tracks
function requestReverbLevels() {
  inputTracks.forEach(t => {
    wwr_req(`GET/TRACK/${t.idx}/SEND/0/VOL`);
  });
}

// Start polling
wwr_req_recur("TRACK", 100);
wwr_start();

// Request reverb levels periodically
setInterval(requestReverbLevels, 2000);
</script>
</body>
</html>
